TIME COMPLEXITY

time complexity is not the actual time taken but the time taken as the function of input size (n)
time  = f(n) -> time complexity

the time complexity let us create scalable systems and let us compare algorithms 

BIG O NOTATION
this represents the upper bound or the worst case complexity

n^2 + n + 1 -> n^2

THETA NOTATION 
this represents the average case time complexity

n^3 + n^2 + n -> n^2

OMEGA NOTATION 
this represents the lower bound or the nest case time compelixity

n^3 + n^2 + n -> n

SPACE COMPLEXITY 

amount of space taken by an algorithm as a function of input size (n)
the input space is not considered, the extra auxillary space which we use is considered

time complexity is more valuable in modern scenerio


Time complexity chart 
O(1) -> O(logn) -> O(n) -> O(nlogn) -> O(n^2) -> O(n^3) -> O(2^n) -> O(n!)


CONSTANT TIME COMPLEXITY

sum of numbers from 1 to n 
printing first element of an array 
last element in the sorted array 
O(1)


adding and deleting from hash maps
ammotized O(1)

LINEAR TIME COMPLEXITY

n factorial 
kadane's algorithm 
nth fibonacci -> DP
Moore's voting algorithm 

N^2 TIME COMPLEXITY

bubble sort 
selection sort
insertion sort 
2 nested loops -> pattern questions

N^3 TIME COMPLEXITY 

possible sub arrays 
triple nested loops

logn TIME COMPLEXITY 

binary search 
binary search trees


nlogn TIME COMPLEXITY 

merge sort
quick sort
greedy algorithm


O(2^n), O(3^n), O(4^n) EXPONENTIAL TIME COMPLEXITY

brute force recursion

O(n!) FACTORIAL TIME COMPLEXITY

4 queens 
knights tour
all possible string permutations

01.cpp -> prime numebrs 

O(logn) -> O(sqrt(n)) -> O(n)

02.cpp -> selection sort

03.cpp -> recursion fibonacci

there are two ways to calculate the time complexity
a. recurrence relation 
b. total no. of rec. calls * work in each call

space complexity in recursion 

there is always an call stack used in recursion 

SC = height of call stack  * memory used in each call 


04.cpp -> recursive fibonacci